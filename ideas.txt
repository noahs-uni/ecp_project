using:
felix NAND
felix OR: not feasible because bad 1's
magic NOT
magic NOR

c_out= NOT (((NOT (a NAND b)) NOR (s NAND c)) NOR ((a NAND b) NOR (s NOR c)))
	t1 = a NAND b
	t2 = s NAND c
	t3 = s NOR c
	t4 = NOT t1 // a AND b
	t5 = t2 NOR t4 // (s NAND c) NOR (a AND b)	
	t6 = t1 NOR t3 // (a NAND b) NOR (s NOR c)
	t7 = t5 NOR t6
	cout = NOT t7

s_out= s XOR c XOR (NOT (a NAND b))
	// using OR/NAND combo to get XOR
	t8 = NOT t3
	t8 = s NAND c // s XOR c
	t9 = t8 NOR t4
	s_out = NOT t9
	s_out = t8 NAND t4 // t8 XOR t4
	
	

Approximation Ideas:
1. Assume a NAND b = 1 / a AND b = 0
2. Replace felix XOR by OR / NAND
3. c_out = !s_out
4. Calculate Approximation bias => combine positive and negative bias PPUs for behavioral model 

Approx. 1
assuming a NAND b = 1 => a AND b = 0 : saving lots of memristors and steps, since NOR(1,x)=0 ; NOR(0,x)=NOT(x) ; XOR(0,x)=x

cout= s AND c
	t1 = s NAND c
	cout = NOT t1

sout= s XOR x
	// using felix OR/NAND combo to get XOR
	t2 = c NOR s
	sout = NOT t2
	sout = c NAND s

Approx. 2
NAND/OR instead of XOR (depending on whether we need positive or negative bias)

cout: same as exact
	t1 = a NAND b
	t2 = s NAND c
	t3 = s NOR c
	t4 = NOT t1 // a AND b
	t5 = t2 NOR t4 // (s NAND c) NOR (a AND b)	
	t6 = t1 NOR t3 // (a NAND b) NOR (s NOR c)
	t7 = t5 NOR t6
	cout = NOT t7

s_out= (NOT (a NAND b) NAND s NAND x)
	t8 = t4 NAND s
	s_out = t8 NAND c
	
Approx. 3
cout: same as exact (sout instead of t7)
sout = !cout

c_out= ((NOT (a NAND b)) NOR (s NAND c)) OR ((a NAND b) NOR (s NOR c))
	t1 = a NAND b
	t2 = s NAND c
	t3 = s NOR c
	t4 = NOT t1 // a AND b
	t5 = t2 NOR t4 // (s NAND c) NOR (a AND b)	
	t6 = t1 NOR t3 // (a NAND b) NOR (s NOR c)
	sout = t5 NOR t6
	cout = NOT sout

Approx. 4
assume b = a: a NAND b => a NAND a => NOT a

c_out= (a NOR (s NAND c)) OR ((NOT a) NOR (s NOR c))
	t1 = NOT a
	t2 = s NAND c
	t3 = s NOR c
	t4 = t2 NOR a	
	t5 = t1 NOR t3 // (NOT a) NOR (s NOR c)
	t6 = t4 NOR t5
	cout = NOT t6

s_out= (NOT (a NAND b) XOR s XOR c)
	// using OR/NAND combo to get XOR
	t7 = NOT t3
	t7 = s NAND c // s XOR c
	t8 = t7 NOR a
	s_out = NOT t8
	s_out = t7 NAND a // t7 XOR a



old ideas:
c_out=majority((a and b), s_in, c_in)
majority as in exercise 
magic and (not in crossbar, but should still work here)

s_out=(a and b) xor s_in xor c_in
felix xor
c = (a or b)
c = (a nand b)
(see paper ccad18...)

step 1:
t1 = a and b
t2 = s or c

step 2:
t3 = minority(t1, s, c)

step 3:
cout = not(t3)
t2 = s nand c // t2 = s xor c

step 4:
sout = t2 or t1

step 5:
sout = t2 nand t1

approx 1:
assume a and b = 0 => cout = s and c; sum = s xor c

approx 2:
just or/nand instead of xor

approx 3:
calculate cout => sout = !cout
